# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'gui/mainMenu.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtGui import QImage, QPixmap
from PyQt5.QtCore import QTimer, QDateTime
from PyQt5.uic import loadUi
from menuSetting import MenuSetting
from config import config
import cv2
import sys
import numpy as np
from tensorflow.keras.models import load_model
from keras.preprocessing import image


class Ui_MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super(Ui_MainWindow, self).__init__()
        loadUi("gui/mainMenu.ui", self)
        self.filename = None
        self.image = None
        self.liveStat = False
        self.timer = QtCore.QTimer(self)
        self.timer.setInterval(1000)
        self.timer.start()
        self.timer.timeout.connect(self.showDatetime)
        self.labelScreen.setStyleSheet("background-color: black")
        self.btnLive.clicked.connect(self.goLive)
        self.btnOpen.clicked.connect(self.loadImage)
        self.actionOpen_File.triggered.connect(self.loadImage)
        self.actionClose.triggered.connect(sys.exit)
        self.actionLoad_Model.triggered.connect(self.openSetting)
        self.model = None
        self.checkPredict.stateChanged.connect(self.checkstate)
        self.btnPredict.clicked.connect(self.singleImage)
        self.checkPredict.setEnabled(False)
        self.btnPredict.setEnabled(False)
        self.pathmodel = config()
        print(len(self.pathmodel['path']))
       

    def getModel(self):
        if len(self.pathmodel['path']) < 1:
            self.openSetting()
        else:
            self.model = load_model(self.pathmodel['path'])


    def goLive(self):
        if self.liveStat:
            self.stopLive()
        else:
            self.pathmodel = config()
            if len(self.pathmodel['path']) < 1:
                self.openSetting()
            else:
                self.model = load_model(self.pathmodel['path'])
                self.liveCam()

    def stopLive(self):
        if self.liveStat:
            self.vtimer.stop()
            self.capture.release()
            self.labelScreen.clear()
            self.liveStat = False
            self.btnLive.setText("LIVE")
            self.checkPredict.setEnabled(False)
            self.btnPredict.setEnabled(False)
            self.btnOpen.setEnabled(True)
            self.actionOpen_File.setEnabled(True)

    def liveCam(self):
        #self.getModel()
        self.liveStat = True
        self.btnLive.setText("STOP LIVE")
        self.checkPredict.setEnabled(True)
        self.btnPredict.setEnabled(True)
        self.btnOpen.setEnabled(False)
        self.actionOpen_File.setEnabled(False)
        cameraName = "0"
        if len(cameraName) == 1:
        	self.capture = cv2.VideoCapture(int(cameraName))
        else:
        	self.capture = cv2.VideoCapture(cameraName)
        self.vtimer = QTimer(self)
        self.vtimer.timeout.connect(self.updateFrame)
        self.vtimer.start(40)

    def updateFrame(self):
        ret, self.image = self.capture.read()
        if ret:
            if self.checkPredict.isChecked() == True:
                self.tampilGambar(self.image, True)
            else:
                self.tampilGambar(self.image, False)
        else:
            print("Camera not ready")
            

    def loadImage(self):
        self.pathmodel = config()
        if len(self.pathmodel['path']) < 1:
            self.openSetting()
        else:
            self.model = load_model(self.pathmodel['path'])
            self.filename = QFileDialog.getOpenFileName(filter="Image (*.*)")[0]
            if len(self.filename) > 3:
                self.image = cv2.imread(self.filename)
                self.tampilGambar(self.image, True)
            

    def tampilGambar(self, original, pred):
        gambar = cv2.resize(original, (400, 400))
        qformat = QImage.Format_Indexed8
        if len(gambar.shape) == 3:
            if gambar.shape[2] == 4:
                qformat = QImage.Format_RGBA8888
            else:
                qformat = QImage.Format_RGB888
        outImage = QImage(gambar, gambar.shape[1], gambar.shape[0], gambar.strides[0], qformat)
        outImage = outImage.rgbSwapped()
        self.labelScreen.setPixmap(QPixmap.fromImage(outImage))
        self.labelScreen.setScaledContents(True)
        if pred:
            thasil = self.prediksi(original)
            self.labelMaterial.setText(thasil)
        
            

    def prediksi(self,gambar):
        img = cv2.resize(gambar, (400,400))
        grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        (thresh, bw) = cv2.threshold(grayImage, 160, 255, cv2.THRESH_BINARY)
        bw = cv2.cvtColor(bw, cv2.COLOR_BGR2RGB)
        x = image.img_to_array(bw)
        x = np.expand_dims(x, axis=0)
        images = np.vstack([x])
        labels = ['Type A', 'Type B']
        classes = self.model.predict(images, batch_size=10)
        #prob = self.model.predict_proba(images, batch_size=10)
        print(classes)
        pred = int(np.argmax(classes, axis=1))
        hasil = labels[pred]
        print(hasil)
        #print(prob)
        return hasil

    def singleImage(self):
        self.stopLive()
        self.tampilGambar(self.image, True)


    def checkstate(self):
        if self.checkPredict.isChecked() == True:
            self.btnPredict.setEnabled(False)
        else:
            self.btnPredict.setEnabled(True)

    def showDatetime(self):
        self.labelTgl.setText(QDateTime.currentDateTime().toString('dd/MM/yyyy'))
    
    def openSetting(self):
        self._new_window = MenuSetting(self)
        self._new_window.show()
    
    def loadSetting(self):
        self._set_window = MenuSetting(self)
        self._set_window.show()


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    ui = Ui_MainWindow()
    ui.show()
    sys.exit(app.exec_())
